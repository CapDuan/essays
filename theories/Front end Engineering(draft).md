1. 设计开发目录，定义开发资源分类（模块化/非模块化）
2. 设计开发目录，降低开发维护成本（开发规范）
3. 根据运维业务要求，设计部署规范（部署规范）
4. 设计工具，完成开发目录和部署目录的转换（开发-部署转换）
5. 设计模块化框架，兼顾性能优化（开发框架）
6. 扩展工具，支持开发框架的构建需求（框架构建需求）
7. 流程整合（开发，测试，联调，上线） 

----------

前后端分离：

* 将原本由服务端负责的数据渲染工作交由前端进行，并且规定前端与服务端之间只能通过标准化协议进行通信。
* 组织架构上的分离，由早期的服务端开发人员顺手去写个界面转变为完整的前端团队构建工程化的前端架构。

----------

* 大体量：多功能、多页面、多状态、多系统；
* 大规模：多人甚至多团队合作开发；
* 高性能：CDN部署、缓存控制、文件指纹、缓存复用、请求合并、按需加载、同步/异步加载、移动端首屏CSS内嵌、HTTP 2.0服务端资源推送。


----------

不能离开场景谈技术

----------

* Node.js：现代工业化前端的基础；
* RequireJS：AMD规范，即将过时的 JavaScript 模块化方案；
* Bower：前端模块源；
* npm；前端工具源，另一个潜在的前端模块源；
* Browserify：即将过时的基于 CommonJS 的前端模块化方案；
* Less：等 CSS 增强工具；
* Gulp：前端构建工具，如果你在前端开发中不需要使用类似工具的话，我只能呵呵；


----------

1. web 1.0 时代
	1. 优点：简单明快，本地起一个 Tomcat 或 Apache 就能开发，调试什么的都还好，只要业务不太复杂。
	2. 缺点：Service 越来越多，调用关系变复杂，前端搭建本地环境不再是一件简单的事
	3. 缺点：JSP 等代码的可维护性越来越差。JSP的强大使得前后端的职责不清晰，JSP 变成了一个灰色地带。经常为了赶项目，为了各种紧急需求，会在 JSP 里揉杂大量业务代码。

2. MVC时代
	1. 优点：MVC 是个非常好的协作模式，从架构层面让开发者懂得什么代码应该写在什么地方
	2. 缺点：前端开发重度依赖开发环境，来回沟通调整的成本比较大，前端开发重度绑定后端环境，环境成为影响前端开发效率的重要因素。
	3. 缺点：前后端分离不够明显，前后端职责依旧纠缠不清。Controller，前端需要关注的路由问题，需要在Controller实现，Controller也会和Model有着扯不清的关系。

3. 2005 年 Ajax 正式提出，web2.0时代来临
	1. 优点：这种模式下，前后端的分工非常清晰，前后端的关键协作点是 Ajax 接口。
	2. 缺点：复杂度从服务端的 JSP 里移到了浏览器的 JavaScript。
	3. 缺点：前端开发的复杂度控制。SPA 应用大多以功能交互型为主，JavaScript 代码过十万行很正常。大量 JS 代码的组织，与 View 层的绑定等，都不是容易的事情。

4. 为了降低前端开发复杂度大量框架涌现。
	1. 前后端职责很清晰。清晰的分工，可以让开发并行，测试数据的模拟不难，前端可以本地开发。后端则可以专注于业务逻辑的处理，输出 RESTful 等接口。
	2. 前端开发的复杂度可控。前端代码很重，但合理的分层，让前端代码能各司其职。
	3. SPA 不能满足所有需求，依旧存在大量多页面应用，URLdesign还需要后端配合
	4. 全异步，对 SEO 不利

5. 全栈时代：
	1. Front-end UI layer 处理浏览器层的展现逻辑。通过 CSS 渲染样式，通过 JavaScript 添加交互功能，HTML 的生成也可以放在这层，具体看应用场景。

　　2. Back-end UI layer 处理路由、模板、数据获取、cookie 等。通过路由，前端终于可以自主把控 URL Design，这样无论是单页面应用还是多页面应用，前端都可以自由调控。后端也终于可以摆脱对展现的强关注，转而可以专心于业务逻辑层的开发。


码农 -> 程序员 -> 工程师

合理的架构，高效的流程